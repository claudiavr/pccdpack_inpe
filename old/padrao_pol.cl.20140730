## Programa automatizador do calculo de polarizacao para estrelas padroes
## Programa reescrito em 17/06/2011
## Versao 2.0
##

procedure padrao_pol

string	object="HD_"		{prompt="Nome do objeto"}
string	lista="@list_obj"	{prompt="Lista de imagens"}
string	imagem				{prompt="Imagem de referencia"}
pset    pospars_inpe		{prompt="Posicoes da lamina de meia onda :e"}
int     nume_lam=16			{prompt="Numero de posicoes da lamina no arquivo dat (max. 16)"}
real	readnoise			{prompt="Ruido de leitura"}
real	gan					{prompt="Ganho"}
real	anel=60				{prompt="Raio interno do anel de ceu"}
real	danel=10			{prompt="Largura do anel de ceu"}
bool	autoabe				{prompt="Define aberturas automaticamente?"}
int		nab					{max=10, prompt="Numero de aberturas"}
int		passoab=1			{prompt="Passo das aberturas"}
int		deltab=-2			{prompt="deslocamento da FWHM"}
string	aberturas			{prompt="Lista de aberturas max = 10"}
bool	registro=no			{prompt="Usa o Xregister para calcular o deslocamento entre as imagens?"}
string	regiao				{prompt="Regiao para a comparacao das imagens (se registro =yes)"}
int		janela				{prompt="Tamanho da janela de correlacao (se registro =yes)"}
bool	acha=no				{prompt="Usa o acha_shift para encontrar o deslocamento entre as imagens?"}
bool	confirma=no			{prompt="Confirma cada imagem com o TVMARK no acha_shift?(se acha =yes)"}
int		tamanho				{prompt="Tamanho do ccd em pixels"}
bool	verify=no			{prompt="Checar parametros do Daophot?"}
real	deltatheta=0.		{prompt="Correcao no angulo de polarizacao"}
bool	nova=yes			{prompt="Medidas obtidas com o novo modulo? (depois de 2007)"}
bool	norma				{prompt="Inclui normalizacao no pccdgen?"}
bool	circular=no			{prompt="No: half-wave plate; Yes: quarter-wave plate."}

struct	*flist1

begin
	
	bool coofaz,faz
	real x1,y1,ceu1,sig1,fwhm1,x2,y2,ceu2,sig2,fwhm2,fwhm,retardancia
	string temp2,temp3,queijo,linedata1,wavetype
	struct line1,lixo,dados,lixo2
	int i,ap
	
	faz=yes
	coofaz=yes

	daophot.datapars.epadu = gan
	daophot.datapars.readnoi = readnoise
	daophot.datapars.datamin = 0
	daophot.datapars.datamax = 40000
	daophot.fitskypars.annulus = anel
	daophot.fitskypars.dannulus = danel
	daophot.findpars.thresho = 4
	daophot.centerpars.calgori="centroid"
	
	
	if(verify){
		daophot.verify = yes
	}
	else{
		daophot.verify = no
	}
	
	if(access("padrao.nfo") && access("padrao.coo")){
		print("OI!")
		print("coornadas da padrao ja encontradas, refazer? y/n")
		lixo2 = scan(coofaz)
		if(coofaz==no){
			flist1 = "padrao.nfo"
			i=0
			while (fscan(flist1,line1) != EOF) {
				if(i==2)linedata1 = fscan(line1,x1,y1,ceu1,sig1,fwhm1)
				if(i==3)linedata1 = fscan(line1,x2,y2,ceu2,sig2,fwhm2)
				i=i+1
			}
			fwhm=(fwhm1+fwhm2)/2
		}
	}
	
	while(coofaz==yes){
		display(image=imagem,frame=1)
		print(" ")
		print("Achando as coordenadas da estrela padrao...")
		print(" ")
		print("Aponte a estrela padrao")
		print("Primeiro o objeto inferior e depois o superior")
		print("Use a letra A para marcar")
		print("Use a letra Q para sair")
	
		delete padrao.coo
		temp3 = mktemp("tmp$padrao")
		unlearn daoedit
		daoedit(imagem,> temp3//"")
		if(access("padrao.nfo")) delete("padrao.nfo")
		copy(temp3, "padrao.nfo")
		
		#type(temp3)
		#type("padrao.nfo")		
		
		flist1 = "padrao.nfo"
		i=0
		while (fscan(flist1,line1) != EOF) {
			if(i==2)linedata1 = fscan(line1,x1,y1,ceu1,sig1,fwhm1)
			if(i==3)linedata1 = fscan(line1,x2,y2,ceu2,sig2,fwhm2)
			i=i+1
		}

		
		fwhm=(fwhm1+fwhm2)/2
	
		temp2 = mktemp("tmp$padrao")
		print("#XCENTER  YCENTER   ID",>temp2)
		print(x1//"	"//y1//" 1",>>temp2)
		print(x2//"	"//y2//" 2",>>temp2)
		if(access("padrao.coo")) delete("padrao.coo")	
		copy(temp2, "padrao.coo")
	
		tvmark.mark = "circle"
		tvmark.radii = 20
		tvmark.color = 206
		tvmark(1,"padrao.coo")
		type("padrao.nfo")
		print("Refazer?")
		lixo = scan(coofaz)
	}
	
	ap=int(fwhm)
		
	if(access(object//"_acha.shift") || access(object//"_xreg.shift")){
		print("ACHA_SHIFT | XREGISTER ja feito, refazer? y/n")
		lixo2 = scan(faz)
	}
	if(faz){
		if(acha){
			print(" ")
			print("Rodando Acha Shift...")
			print(" ")
			acha_shift(imgref=imagem,images=lista,shifts=object,confirm=confirma)
		}
		if(registro){
			print(" ")
			print("Calculando o deslocamento entre as imagens com o Xregister")
			print(" ")
			delete object//"_xreg.shift"
			unlearn xregister
			xregister(input=lista,referenc=imagem,regions=regiao,shifts=object//"_xreg.shift",databas=no,xwindow=janela,ywindow=janela)
		}
	}

	if(autoabe){
#		photpars.apertur=ap-2//","//ap-1//","//ap//","//ap+1//","//ap+2//","//ap+3//","//ap+4//","//ap+5//","//ap+6//","//ap+7
		daophot.photpars.apertur=""
		i=0
		while(i<nab){
			if(i<(nab-1))daophot.photpars.apertur=photpars.apertur//ap+deltab+passoab*i//","
			if(i==(nab-1))daophot.photpars.apertur=photpars.apertur//ap+deltab+passoab*i
			i=i+1
		}
		print(daophot.photpars.apertur)
	}
	if(autoabe==no)	daophot.photpars.apertur = aberturas
	
	if(registro){
		unlearn ordshift
		ordshift(infile=object//"_xreg.shift",coorfil="padrao.coo",xside=tamanho,yside=tamanho)
		print(" ")
		print("Fazendo a fotometria de abertura")
		print(" ")
		delete "*.mag.1"
		daophot.phot(image=lista, coords="@inord", output="default")
	}
	if(acha){
		unlearn ordshift
		ordshift(infile=object//"_acha.shift",coorfil="padrao.coo",xside=tamanho,yside=tamanho)
		print(" ")
		print("Fazendo a fotometria de abertura")
		print(" ")
		delete "*.mag.1"
		daophot.phot(image=lista, coords="@inord", output="default")
	
	}
	if(registro==no && acha==no){
		unlearn phot
		print(" ")
		print("Fazendo a fotometria de abertura!")
		print(" ")
		delete "*.mag.1"
		daophot.phot(image=lista, coords="padrao.coo", output="default")
	}
	!ls *.mag.1>list_mag
	unlearn cria_dat
	cria_dat(varim="@list_mag", outdat="dat", interva = nume_lam)
	print(" ")
	print("Calculando a polarizacao!")
	print("  ")
	if (circular) {
		wavetype="quarter"
		retardancia=90.
		} 
		else {
		wavetype="half"
		retardancia=180.
	}				 
    pccdgen_inpe(filename="dat.001",nstars=1,wavetyp=wavetype,retar=retardancia,nhw=nume_lam,nap=nab,calc="c",readnoi=readnoise,ganho=gan,deltath=deltatheta, norm=norma, new_mod=nova, zero=0., fileout=object//".log")
	print("  ")
	print("Calculando a abertura com o menor erro")
	print(" ")
	macrol_inpe(file_in=object//".log", file_out=object, minimun="full")
	print(" ")
	print("Resultado da polarizacao:")
	type(input_fi=object//".out")
	
	#delete(temp3,ver-)
	#delete(temp2,ver-)
	print(" ") 
end

