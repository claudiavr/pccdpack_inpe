## Programa automatizador do calculo de polarizacao para multiplos objetos
## Programa reescrito em 18/06/2011
## Agora pega parametros do clestat
## Versao 2.1 - 19/10/2011
##



procedure auto_pol

string	object				{prompt="Nome do objeto"}
string	lista				{prompt="Lista de imagens"}
string	imagem				{prompt="Imagem de referencia"}
pset    pospars_inpe		{prompt="Posicoes da lamina de meia onda :e"}
int     nume_lam			{prompt="Numero de posicoes da lamina no arquivo dat (max. 16)"}
real	deltatheta=0.		{prompt="Correcao no angulo de polarizacao"}
bool	norma				{prompt="Inclui normalizacao no pccdgen?"}
bool	nova				{prompt="Medidas obtidas com o novo modulo? (depois de 2007)"}
real	readnoise			{prompt="Ruido de leitura"}
real	gan					{prompt="Ganho"}
real	anel=60				{prompt="Raio interno do anel de ceu"}
real	danel=10			{prompt="Largura do anel de ceu"}
bool	autoabe				{prompt="Define aberturas automaticamente?"}
int		nab=10				{max=10, prompt="Numero de aberturas"}
int		passoab=1			{prompt="Passo das aberturas"}
int		deltab=-2			{prompt="deslocamento da FWHM"}
string	aberturas			{prompt="Lista de aberturas max = 10"}
bool	verify=no			{prompt="Checar parametros do daophot?"}
real	delx=2				{prompt="Erro permitido no eixo x para a formacao de pares"}
real	dely=2				{prompt="Erro permitido no eixo y para a formacao de pares"}
real	delmag=0.5			{prompt="Erro permitido em magnitudes"}
bool	registro			{prompt="Usa o Xregister para calcular o deslocamento entre as imagens?"}
string	regiao				{prompt="Regiao para a comparacao das imagens"}
int		janela				{prompt="Tamanho da janela de correlacao"}
int		tamanho				{prompt="Tamanho do ccd em pixels"}
bool	acha				{prompt="Usa o acha_shift para encontrar o deslocamento entre as imagens?"}
bool	confirma=no			{prompt="Confirma cada imagem com o TVMARK no acha_shift?"}
int		passo=1				{min=1,max=5, prompt="Comeca de qual passo (1 = tudo, 2 = ordem, 3 = Deslocamento, 4 = Fotometria, 5 = Polarizacao)?"}
#bool	faz=yes				{prompt="Faz acha_shift (se ja houver um _acha.shift, pode colocar no)"}
int		nestrelas			{prompt="Numero de estrelas, usar apenas se passo > 4"}

struct *flist1


begin

	struct line
	string lixo,dados,lado,lixo2,temp
	real lixoreal,fwhm,sigma,shx,shy
	bool fazclest,faz
	int ap,i 
	
	faz=yes
	fazclest=yes
	
	if(verify){
		daophot.verify = yes
	}
	else{
		daophot.verify = no
	}
	
	if(access("estat.log")){
		print("CLESTAT ja feito, refazer? y/n")
		lixo2 = scan(fazclest)
	}
	if(fazclest){
		clestat(imagem)
	}
	
	flist1 = "estat.log"
	lixo = fscan(flist1)
	dados = fscan(flist1,shx,shy)
	lixo = fscan(flist1)
	dados = fscan(flist1,lixoreal,sigma,fwhm)
	
	if(shx > 0) lado="right"
	if(shx < 0) lado="left"
	
	print(lado)
	
	### Achando os deslocamentos entre as imagens com acha shift###
	if(access(object//"_acha.shift")){
		print("ACHA_SHIFT ja feito, refazer? y/n")
		lixo2 = scan(faz)
	}
	if(faz){
		if(passo<4){
			if(acha){
				if(access(object//"_acha.shift")) delete(object//"_acha.shift",ver-)
				acha_shift(imgref=imagem,images=lista,shifts=object,confirm=confirma)
			}
		}
	}
	daophot.datapars.epadu = gan
	daophot.datapars.readnoi = readnoise
	daophot.datapars.fwhmpsf = fwhm
	daophot.datapars.sigma = sigma
	daophot.findpars.thresho = 4
	print(datapars.sigma,datapars.fwhmpsf)
	daophot.datapars.datamax = 60000
	daophot.datapars.datamin = 0
	daophot.centerpars.calgori="centroid"
	daophot.fitskypars.annulus = anel
	daophot.fitskypars.dannulus = danel
	
	ap=int(fwhm)
	if(autoabe){
#		photpars.apertur=ap-2//","//ap-1//","//ap//","//ap+1//","//ap+2//","//ap+3//","//ap+4//","//ap+5//","//ap+6//","//ap+7
		daophot.photpars.apertur=""
		i=0
		while(i<nab){
			if(i<(nab-1))daophot.photpars.apertur=photpars.apertur//ap+deltab+passoab*i//","
			if(i==(nab-1))daophot.photpars.apertur=photpars.apertur//ap+deltab+passoab*i
			i=i+1
		}
		print(daophot.photpars.apertur)
	}
	if(autoabe==no)	daophot.photpars.apertur = aberturas
	
	if(passo==1){
		print("Achando as estrelas do campo")
		if(access(object//".coo")) delete(object//".coo",ver-)
		daophot.daofind(image=imagem,output=object//".coo")
	}
	if(passo<3){
		print("Encontrando os pares ordinario e extraordinario")
		unlearn ordem_inpe
		ordem3(shiftx=shx,shifty=shy,deltax=delx,deltay=dely,deltamag=delmag,pripar=no,side=lado,file_in=object//".coo", file_out=object)
	}
	if(registro){
		if(passo<4){
			print("Calculando o deslocamento entre as imagens")
			delete object//"_xreg.shift"
			unlearn xregister
			xregister(input=lista,referenc=imagem,regions=regiao,shifts=object//"_xreg.shift",databas=no,xwindow=janela,ywindow=janela)
			unlearn ordshift
			ordshift(infile=object//"_xreg.shift",coorfil=object//".ord",xside=tamanho,yside=tamanho)
			nestrelas=ordshift.nobj
		}
		if(passo<5){
			print("Fazendo a fotometria de abertura")
			delete "*.mag.1"
			daophot.phot(image=lista, coords="@inord", output="default")
		}
	}
	if(acha){
		if(passo<4){
			ordshift(infile=object//"_acha.shift",coorfil=object//".ord",xside=tamanho,yside=tamanho)
			nestrelas=ordshift.nobj
		}
		if(passo<5){
			print("Fazendo a fotometria de abertura")
			delete "*.mag.1"
			daophot.phot(image=lista, coords="@inord", output="default")
		}
	}
	if(registro==no && acha==no){
		nestrelas = ordem_inpe.npar
		unlearn phot
		if(passo<5){
			print("Fazendo a fotometria de abertura!")
			delete "*.mag.1"
			daophot.phot(image=lista, coords=object//".ord", output="default")
		}
	}
	if(registro==yes || acha ==yes) nestrelas=ordshift.nobj
	if(passo<6){
		delete dat.001
		delete list_mag
		!ls *.mag.1>list_mag
		unlearn cria_dat
		cria_dat(varim="@list_mag", outdat="dat", interva = nume_lam)
		print("Calculando a polarizacao!")
		tstat("dat.001",2)
		auto_pol.nestrelas=tstat.nrows/(nume_lam*2)
		pccdgen_inpe(filename="dat.001",nstars=nestrelas,wavetyp="half",retar=180.,nhw=nume_lam,nap=nab,calc="c",readnoi=readnoise,ganho=gan,deltath=deltatheta, norm=norma, new_mod=nova, zero=0., fileout=object//".log")
		print("Calculando a abertura com o menor erro")
		macrol_inpe(file_in=object//".log", file_out=object, minimun="full")
		print("Visualizar resultado com a rotina select")
    }
	
	#temp=mktemp("tmp$auto_pol")
	lpar auto_pol | page > auto.par
	#delete(temp, ver-)
	!say "Job Done"
	#beep
end