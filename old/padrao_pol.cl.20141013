## Programa automatizador do calculo de polarizacao para estrelas padroes
## Programa reescrito em 17/06/2011
## Versao 2.0
##
## Julho/2014 - Claudia V. Rodrigues
## - Incluida opcao de polarimetria circular
## - modificado modo de escolher o metodo do calculo do deslocamento de imagens
## - os deletes estao forcados a nao pedir verificacao
## - acertei pequenos problemas na secao de configuracao das aberturas
## - inclui opcao que permite conferencia dos deslocamentos (display + tvmark de todos
##      os arquivos)
##

procedure padrao_pol

string	object="HD_"		{prompt="Nome do objeto"}
string	lista="@list_obj"	{prompt="Lista de imagens"}
string	imagem				{prompt="Imagem de referencia"}
pset    pospars_inpe		{prompt="Posicoes da lamina de meia onda :e"}
int     nume_lam=16			{prompt="Numero de posicoes da lamina no arquivo dat (max. 16)"}
real	readnoise			{prompt="Ruido de leitura"}
real	gan					{prompt="Ganho"}
real	anel=60				{prompt="Raio interno do anel de ceu"}
real	danel=10			{prompt="Largura do anel de ceu"}
bool	autoabe=yes			{prompt="Define aberturas automaticamente?"}
int		nab=10				{max=10, prompt="Numero de aberturas"}
int		passoab=1			{prompt="Passo das aberturas"}
int		deltab=-2			{prompt="deslocamento da FWHM"}
string	aberturas			{prompt="Lista de aberturas max = 10"}
string  desloca='xregister'	{enum="no|xregister|acha_shift", prompt="Method to calculate images shifts"}
#bool	registro=no			{prompt="Usa o Xregister para calcular o deslocamento entre as imagens?"}
string	regiao				{prompt="Regiao para a comparacao das imagens (if desloca=xregister)"}
int		janela				{prompt="Tamanho da janela de correlacao (if desloca=xregister)"}
#bool	acha=no				{prompt="Usa o acha_shift para encontrar o deslocamento entre as imagens?"}
#bool	confirma=no			{prompt="Confirma cada imagem com o TVMARK no acha_shift?(if desloca = acha_shift)"}
bool	confirma=no			{prompt="Mostra TVMARK dos arquivos de coordenadas em cada imagem."}
int		tamanho=1024		{prompt="Tamanho do ccd em pixels"}
bool	verify=yes			{prompt="Checar parametros do Daophot?"}
real	deltatheta=0.		{prompt="Correcao no angulo de polarizacao"}
bool	nova=yes			{prompt="Medidas obtidas com o novo modulo? (depois de 2007)"}
bool	norma=yes			{prompt="Inclui normalizacao no pccdgen?"}
bool	circular=no			{prompt="No: half-wave plate; Yes: quarter-wave plate."}
real	zero=0.				{prompt="Zero position of quarter-wave plate"}

struct	*flist1
struct	*flist2

begin
	
	bool coofaz,faz
	real x1,y1,ceu1,sig1,fwhm1,x2,y2,ceu2,sig2,fwhm2,fwhm,retardancia,zero_par
	string temp2,temp3,queijo,linedata1,wavetype,arq_coord,varima,vtmpfile,namev
	struct line1,lixo,dados,lixo2
	int i,ap,next_ap
	
	faz=yes
	coofaz=yes

#######
# CVR - A configuracao abaixo dos parametros do daophot esta correta. Pode ser verificado
#    no console. Mas na hora de rodar o phot (daophot.phot) sao usados os par do apphot.
# 	 Forcei setagem nos dois pacotes.
######
	daophot.datapars.epadu = gan
	daophot.datapars.readnoi = readnoise
	daophot.datapars.datamin = 0
	daophot.datapars.datamax = 60000
	daophot.fitskypars.annulus = anel
	daophot.fitskypars.dannulus = danel
	daophot.findpars.thresho = 4
	daophot.centerpars.calgori="centroid"
#
	apphot.datapars.epadu = gan
	apphot.datapars.readnoi = readnoise
	apphot.datapars.datamin = 0
	apphot.datapars.datamax = 60000
	apphot.fitskypars.annulus = anel
	apphot.fitskypars.dannulus = danel
	apphot.findpars.thresho = 4
	apphot.centerpars.calgori="centroid"
##	
	if(verify){
		daophot.verify = yes
	}
	else{
		daophot.verify = no
	}
	
	if(access("padrao.nfo") && access("padrao.coo")){
		coofaz=no
		print("Coordenadas da padrao ja encontradas, refazer? y/n - no (default)")
		lixo2 = scan(coofaz)
		if(coofaz==no){
			flist1 = "padrao.nfo"
			i=0
			while (fscan(flist1,line1) != EOF) {
				if(i==2)linedata1 = fscan(line1,x1,y1,ceu1,sig1,fwhm1)
				if(i==3)linedata1 = fscan(line1,x2,y2,ceu2,sig2,fwhm2)
				i=i+1
			}
			fwhm=(fwhm1+fwhm2)/2
		}
	}
	
	while(coofaz==yes){
		display(image=imagem,frame=1)
		print(" ")
		print("Achando as coordenadas da estrela padrao...")
		print(" ")
		print("Aponte a estrela padrao")
		print("Primeiro o objeto inferior e depois o superior")
		print("Use a letra A para marcar")
		print("Use a letra Q para sair")
	
		if(access("padrao.coo")) delete("padrao.coo",ver-)
		temp3 = mktemp("tmp$padrao")
		unlearn daoedit
		daoedit(imagem,> temp3//"")
		if(access("padrao.nfo")) delete("padrao.nfo",ver-)
		copy(temp3, "padrao.nfo")
		
		#type(temp3)
		#type("padrao.nfo")		
		
		flist1 = "padrao.nfo"
		i=0
		while (fscan(flist1,line1) != EOF) {
			if(i==2)linedata1 = fscan(line1,x1,y1,ceu1,sig1,fwhm1)
			if(i==3)linedata1 = fscan(line1,x2,y2,ceu2,sig2,fwhm2)
			i=i+1
		}

		
		fwhm=(fwhm1+fwhm2)/2
	
		temp2 = mktemp("tmp$padrao")
		print("#XCENTER  YCENTER   ID",>temp2)
		print(x1//"	"//y1//" 1",>>temp2)
		print(x2//"	"//y2//" 2",>>temp2)
		if(access("padrao.coo")) delete("padrao.coo",ver-)	
		copy(temp2, "padrao.coo")
	
		tvmark.mark = "circle"
		tvmark.radii = 20
		tvmark.color = 206
		tvmark(1,"padrao.coo")
		type("padrao.nfo")
		print("Refazer? No is default.")
		coofaz=no
		lixo = scan(coofaz)
	}
	
	ap=int(fwhm)

		
	if(access(object//"_acha.shift") || access(object//"_xreg.shift")){
		faz=no
		print("ACHA_SHIFT | XREGISTER ja feito, refazer? y/no - no (default)")
		lixo2 = scan(faz)
	}
	if(faz){
		if(desloca == 'acha_shift'){
			print(" ")
			print("Rodando Acha Shift...")
			print(" ")
			acha_shift(imgref=imagem,images=lista,shifts=object,confirm=confirma)
		} else
		if(desloca == 'xregister'){
			print(" ")
			print("Calculando o deslocamento entre as imagens com o Xregister")
			print(" ")
			delete(object//"_xreg.shift",ver-)
			unlearn xregister
			xregister(input=lista,referenc=imagem,regions=regiao,shifts=object//"_xreg.shift",databas=no,xwindow=janela,ywindow=janela)
		}
	}
###
### ******* SETANDO ABERTURAS ************
###
	if(autoabe){
#		photpars.apertur=ap-2//","//ap-1//","//ap//","//ap+1//","//ap+2//","//ap+3//","//ap+4//","//ap+5//","//ap+6//","//ap+7
		daophot.photpars.apertur=""
		i=0
		while(i<nab){
			next_ap=ap+deltab+passoab*i
			if(i<(nab-1))daophot.photpars.apertur=daophot.photpars.apertur//next_ap//","
			if(i==(nab-1))daophot.photpars.apertur=daophot.photpars.apertur//next_ap
#			print(next_ap)
#			print(daophot.photpars.apertur)
			i=i+1
		}
#		print(daophot.photpars.apertur)
	}
	if(autoabe==no)	daophot.photpars.apertur = aberturas
		
	apphot.photpars.apertur=daophot.photpars.apertur
#
###
#### APLICANDO DESLOCAMENTO NOS ARQUIVOS DE COORD. E FAZENDO FOTOMETRIA DE ABERTURA ######
#
	print(" ")
	print("Aplicando o deslocamento nos arquivos de coordenadas.")
	print(" ")
#	
	if(desloca == 'xregister'){
		unlearn ordshift
		ordshift(infile=object//"_xreg.shift",coorfil="padrao.coo",xside=tamanho,yside=tamanho)
		print(" ")
		print("Fazendo a fotometria de abertura")
		print(" ")
		delete("*.mag.1",ver-)
		daophot.phot(image=lista, coords="@inord", output="default")
	} else
	if(desloca == 'acha_shift'){
		unlearn ordshift
		ordshift(infile=object//"_acha.shift",coorfil="padrao.coo",xside=tamanho,yside=tamanho)
		print(" ")
		print("Fazendo a fotometria de abertura")
		print(" ")
		delete("*.mag.1",ver-)
		daophot.phot(image=lista, coords="@inord", output="default")	
	} else
	if(desloca == 'no'){
		#unlearn phot
		print(" ")
		print("Fazendo a fotometria de abertura!")
		print(" ")
		delete("*.mag.1",ver-)
		daophot.phot(image=lista, coords="padrao.coo", output="default")
	}

###
#### CONFERINDO DESLOCAMENTO VISUALMENTE ######
#
	if(confirma) {
		tvmark.mark = "circle"
		tvmark.radii = 20
		tvmark.color = 206
        # Create list of input star images in a temporary file
        varima=lista
        vtmpfile = mktemp ("/tmp/tmpvar")
        files (varima, > vtmpfile)
        flist1 = vtmpfile
        #
        varima="@inord"
        vtmpfile = mktemp ("/tmp/tmpvar")
        files (varima, > vtmpfile)
        flist2 = vtmpfile
        arq_coord=" "
# 
#	 	print(" ")
		print("Va para o DS9 conferindo o registro.")
		print(" ")
#
        while (fscan(flist1, namev) != EOF) 
        {
		  lixo = fscan(flist2, arq_coord)
		  print(namev,"  ",arq_coord,"  Enter para proxima imagem.")
          display(namev,frame=1)
          tvmark(1,arq_coord)          
		  lixo = scan(coofaz)  # le variavel ja usada
        }
        delete(vtmpfile,ver-)
	}

###
#### CRIANDO DAT FILE E FAZENDO POLARIMETRIA ######
#	
	!ls *.mag.1>list_mag
	unlearn cria_dat
	cria_dat(varim="@list_mag", outdat="dat", interva = nume_lam)
	print(" ")
	print("Calculando a polarizacao!")
	print("  ")
	if (circular) {
		wavetype="quarter"
		retardancia=90.
		zero_par=zero
		} 
		else {
		wavetype="half"
		retardancia=180.
		zero_par=0.
	}				 
    pccdgen_inpe(filename="dat.001",nstars=1,wavetyp=wavetype,retar=retardancia,nhw=nume_lam,nap=nab,calc="c",readnoi=readnoise,ganho=gan,deltath=deltatheta, norm=norma, new_mod=nova, zero=zero_par, fileout=object//".log")
	print("  ")
	print("Calculando a abertura com o menor erro")
	print(" ")
	macrol_inpe(file_in=object//".log", file_out=object, minimun="full")
	print(" ")
	print("Resultado da polarizacao:")
	type(input_fi=object//".out")
	
	#delete(temp3,ver-)
	#delete(temp2,ver-)
	print(" ") 	
end

